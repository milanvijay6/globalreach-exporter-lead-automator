import { Logger } from './loggerService';
import { PurchaseOrder, PurchasePattern, CustomerIntent, CustomerIntentType } from '../types';
import { PurchasePatternAnalysisService } from './purchasePatternAnalysisService';

/**
 * Customer Intent Inference Service
 * Predicts upcoming purchases and identifies opportunities
 */
export const CustomerIntentService = {
  /**
   * Infers customer intent from purchase patterns
   */
  inferCustomerIntent: (
    pattern: PurchasePattern,
    allOrders: PurchaseOrder[]
  ): CustomerIntent => {
    const now = Date.now();
    const daysSinceLastOrder = (now - pattern.lastPurchaseDate) / (1000 * 60 * 60 * 24);
    const typicalCycle = pattern.purchaseFrequency;

    let intentType: CustomerIntentType;
    let confidenceScore = 0.5;

    // Determine intent type
    if (daysSinceLastOrder > typicalCycle * 1.5) {
      // Beyond typical cycle - likely imminent order
      intentType = CustomerIntentType.IMMINENT_ORDER;
      confidenceScore = Math.min(0.9, 0.5 + (daysSinceLastOrder / typicalCycle) * 0.1);
    } else if (daysSinceLastOrder > typicalCycle * 2) {
      // Way beyond cycle - dormant
      intentType = CustomerIntentType.DORMANT;
      confidenceScore = 0.7;
    } else if (pattern.totalOrders >= 3 && typicalCycle > 0) {
      // Regular cycle customer
      intentType = CustomerIntentType.REGULAR_CYCLE;
      confidenceScore = 0.8;
    } else {
      // New or irregular customer
      intentType = CustomerIntentType.IMMINENT_ORDER;
      confidenceScore = 0.4;
    }

    // Predict next purchase
    const prediction = CustomerIntentService.predictNextPurchase(pattern, allOrders);

    // Identify upsell opportunities
    const upsellOpportunities = CustomerIntentService.identifyUpsellOpportunities(
      pattern,
      allOrders
    );

    // Build analysis summary
    const analysisSummary = CustomerIntentService.buildAnalysisSummary(
      pattern,
      daysSinceLastOrder,
      intentType
    );

    // Build order prediction
    const orderPrediction = CustomerIntentService.buildOrderPrediction(
      prediction,
      pattern,
      upsellOpportunities
    );

    const intent: CustomerIntent = {
      customerId: pattern.customerId,
      customerName: pattern.customerName,
      contactNo: allOrders.find(o => 
        PurchasePatternAnalysisService.getCustomerId(o) === pattern.customerId
      )?.contactNo,
      emailId: allOrders.find(o => 
        PurchasePatternAnalysisService.getCustomerId(o) === pattern.customerId
      )?.emailId,
      intentType,
      predictedProducts: prediction.products,
      predictedQuantities: prediction.quantities,
      confidenceScore,
      recommendedMessage: '', // Will be generated by message service
      analysisSummary,
      orderPrediction,
      lastOrderDate: pattern.lastPurchaseDate,
      daysSinceLastOrder: Math.round(daysSinceLastOrder),
      typicalCycleDays: Math.round(typicalCycle),
    };

    return intent;
  },

  /**
   * Predicts next purchase date and quantities
   */
  predictNextPurchase: (
    pattern: PurchasePattern,
    allOrders: PurchaseOrder[]
  ): {
    date: number;
    products: Array<{ productDescription: string; predictedQuantity: number; confidence: number }>;
    quantities: Record<string, number>;
  } => {
    const customerOrders = PurchasePatternAnalysisService.getCustomerOrders(
      allOrders,
      pattern.customerId
    );

    // Predict next date
    const nextDate = pattern.nextPredictedDate;

    // Predict quantities based on historical average with some variance
    const predictedQuantity = Math.round(
      pattern.averageQuantity * (0.8 + Math.random() * 0.4) // 80-120% of average
    );

    const products: Array<{ productDescription: string; predictedQuantity: number; confidence: number }> = [
      {
        productDescription: pattern.productDescription,
        predictedQuantity,
        confidence: pattern.totalOrders >= 3 ? 0.8 : 0.5,
      },
    ];

    // Add related products if available
    if (pattern.relatedProducts && pattern.relatedProducts.length > 0) {
      for (const relatedProduct of pattern.relatedProducts.slice(0, 2)) {
        // Find average quantity for related product
        const relatedOrders = customerOrders.filter(
          o => o.productDescription.toLowerCase().trim() === relatedProduct
        );
        if (relatedOrders.length > 0) {
          const avgQty = relatedOrders.reduce((sum, o) => sum + o.quantity, 0) / relatedOrders.length;
          products.push({
            productDescription: relatedProduct,
            predictedQuantity: Math.round(avgQty),
            confidence: 0.5, // Lower confidence for related products
          });
        }
      }
    }

    const quantities: Record<string, number> = {};
    products.forEach(p => {
      quantities[p.productDescription] = p.predictedQuantity;
    });

    return {
      date: nextDate,
      products,
      quantities,
    };
  },

  /**
   * Identifies upsell and cross-sell opportunities
   */
  identifyUpsellOpportunities: (
    pattern: PurchasePattern,
    allOrders: PurchaseOrder[]
  ): Array<{ product: string; reason: string; confidence: number }> => {
    const opportunities: Array<{ product: string; reason: string; confidence: number }> = [];

    // Check for related products not recently ordered
    if (pattern.relatedProducts && pattern.relatedProducts.length > 0) {
      const customerOrders = PurchasePatternAnalysisService.getCustomerOrders(
        allOrders,
        pattern.customerId
      );
      const recentOrders = customerOrders.filter(
        o => (Date.now() - o.orderDate) / (1000 * 60 * 60 * 24) <= 90
      );

      for (const relatedProduct of pattern.relatedProducts) {
        const hasRecentOrder = recentOrders.some(
          o => o.productDescription.toLowerCase().trim() === relatedProduct
        );

        if (!hasRecentOrder) {
          opportunities.push({
            product: relatedProduct,
            reason: 'Frequently bought together but not ordered recently',
            confidence: 0.6,
          });
        }
      }
    }

    // Check for quantity increase opportunity
    const recentOrders = allOrders
      .filter(o => PurchasePatternAnalysisService.getCustomerId(o) === pattern.customerId)
      .filter(o => (Date.now() - o.orderDate) / (1000 * 60 * 60 * 24) <= 180)
      .sort((a, b) => b.orderDate - a.orderDate);

    if (recentOrders.length >= 2) {
      const lastQuantity = recentOrders[0].quantity;
      const previousQuantity = recentOrders[1].quantity;

      if (lastQuantity > previousQuantity * 1.2) {
        // Quantity is increasing - suggest larger order
        opportunities.push({
          product: pattern.productDescription,
          reason: 'Purchase quantity showing upward trend',
          confidence: 0.7,
        });
      }
    }

    return opportunities;
  },

  /**
   * Calculates confidence score for intent
   */
  calculateIntentConfidence: (pattern: PurchasePattern, daysSinceLastOrder: number): number => {
    let confidence = 0.5;

    // More orders = higher confidence
    if (pattern.totalOrders >= 5) confidence += 0.2;
    else if (pattern.totalOrders >= 3) confidence += 0.1;

    // Regular cycle = higher confidence
    if (pattern.purchaseCycle !== 'irregular') confidence += 0.1;

    // Close to predicted date = higher confidence
    const daysUntilPredicted = (pattern.nextPredictedDate - Date.now()) / (1000 * 60 * 60 * 24);
    if (Math.abs(daysUntilPredicted) <= 7) confidence += 0.1;

    return Math.min(0.95, confidence);
  },

  /**
   * Builds analysis summary text
   */
  buildAnalysisSummary: (
    pattern: PurchasePattern,
    daysSinceLastOrder: number,
    intentType: CustomerIntentType
  ): string => {
    const customerName = pattern.customerName.split(' ')[0]; // First name
    const cycleText = pattern.purchaseCycle === 'weekly' ? 'weekly' :
                     pattern.purchaseCycle === 'monthly' ? 'monthly' :
                     pattern.purchaseCycle === 'quarterly' ? 'quarterly' :
                     pattern.purchaseCycle === 'seasonal' ? 'seasonal' : 'irregular';

    if (intentType === CustomerIntentType.IMMINENT_ORDER) {
      return `${customerName} consistently purchases ${pattern.productDescription} every ${Math.round(pattern.purchaseFrequency)}â€“${Math.round(pattern.purchaseFrequency * 1.2)} days, last order placed ${Math.round(daysSinceLastOrder)} days ago.`;
    } else if (intentType === CustomerIntentType.REGULAR_CYCLE) {
      return `${customerName} has a ${cycleText} purchase pattern for ${pattern.productDescription}, with ${pattern.totalOrders} orders totaling $${pattern.totalSpend.toFixed(2)}.`;
    } else if (intentType === CustomerIntentType.DORMANT) {
      return `${customerName} has not placed an order for ${pattern.productDescription} in ${Math.round(daysSinceLastOrder)} days, which is beyond their typical ${Math.round(pattern.purchaseFrequency)}-day cycle.`;
    } else {
      return `${customerName} has ordered ${pattern.productDescription} ${pattern.totalOrders} times with an average quantity of ${pattern.averageQuantity.toFixed(1)}.`;
    }
  },

  /**
   * Builds order prediction text
   */
  buildOrderPrediction: (
    prediction: { date: number; products: Array<{ productDescription: string; predictedQuantity: number; confidence: number }>; quantities: Record<string, number> },
    pattern: PurchasePattern,
    upsellOpportunities: Array<{ product: string; reason: string; confidence: number }>
  ): string => {
    const daysUntil = Math.round((prediction.date - Date.now()) / (1000 * 60 * 60 * 24));
    const mainProduct = prediction.products[0];
    
    let predictionText = `He will likely require ${mainProduct.predictedQuantity} ${pattern.unitQuantity || 'units'} of ${mainProduct.productDescription}`;

    if (daysUntil > 0) {
      predictionText += ` within the next ${daysUntil} days`;
    } else if (daysUntil > -7) {
      predictionText += ` soon (overdue by ${Math.abs(daysUntil)} days)`;
    } else {
      predictionText += ` (overdue by ${Math.abs(daysUntil)} days)`;
    }

    if (prediction.products.length > 1) {
      const additionalProducts = prediction.products.slice(1)
        .map(p => `${p.predictedQuantity} ${pattern.unitQuantity || 'units'} of ${p.productDescription}`)
        .join(' and ');
      predictionText += `. Also likely to need ${additionalProducts}.`;
    }

    if (upsellOpportunities.length > 0) {
      const upsellProduct = upsellOpportunities[0].product;
      predictionText += ` Cross-sell opportunity: ${upsellProduct}.`;
    }

    return predictionText;
  },
};

